-- =====================================================
-- TraceRoo Phase 3: Dashboard & Trace Enhancements
-- Supabase Migration Script
-- Run this in Supabase SQL Editor AFTER Phase 2
-- =====================================================

-- =====================================================
-- 0. CREATE TRACE_EVENT TABLE IF NOT EXISTS
-- Ensure the trace_event table exists with proper columns
-- =====================================================
CREATE TABLE IF NOT EXISTS trace_event (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    event_type TEXT NOT NULL,
    event_category TEXT CHECK (event_category IN ('OBJECT', 'AGGREGATION', 'DISAGGREGATION', 'TRANSFER', 'SHIPMENT', 'EXCEPTION')),
    event_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    location TEXT,
    "user" TEXT,
    notes TEXT,
    status TEXT,
    inventory_id BIGINT,
    container_id BIGINT,
    batch_number TEXT,
    order_reference TEXT,
    owner TEXT,
    shipment_id BIGINT,
    parent_container_id BIGINT,
    child_ids JSONB,
    location_id UUID REFERENCES locations(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_trace_event_type ON trace_event(event_type);
CREATE INDEX IF NOT EXISTS idx_trace_event_timestamp ON trace_event(event_timestamp);
CREATE INDEX IF NOT EXISTS idx_trace_event_inventory ON trace_event(inventory_id);

-- Enable RLS
ALTER TABLE trace_event ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Enable all access for authenticated users" ON trace_event
    FOR ALL TO authenticated USING (true) WITH CHECK (true);

CREATE POLICY "Enable read access for anon" ON trace_event
    FOR SELECT TO anon USING (true);

-- =====================================================
-- 1. DASHBOARD METRICS VIEW
-- Aggregated metrics for the dashboard
-- =====================================================
CREATE OR REPLACE VIEW dashboard_metrics AS
SELECT 
    -- Inventory counts by status
    (SELECT COUNT(*) FROM inventory WHERE status = 'PRE_INVENTORY') as pre_inventory_count,
    (SELECT COUNT(*) FROM inventory WHERE status = 'ACTIVE') as active_inventory_count,
    (SELECT COUNT(*) FROM inventory WHERE status = 'PACKED') as packed_count,
    (SELECT COUNT(*) FROM inventory WHERE status = 'SHIPPED') as shipped_count,
    (SELECT COUNT(*) FROM inventory WHERE status = 'DELIVERED') as delivered_count,
    (SELECT COUNT(*) FROM inventory) as total_inventory_count,
    
    -- Container counts by type
    (SELECT COUNT(*) FROM container_unit WHERE container_type = 'BOX') as box_count,
    (SELECT COUNT(*) FROM container_unit WHERE container_type = 'PALLET') as pallet_count,
    (SELECT COUNT(*) FROM container_unit WHERE container_type = 'SHIPPING_CONTAINER') as shipping_container_count,
    (SELECT COUNT(*) FROM container_unit WHERE status = 'SEALED') as sealed_containers,
    
    -- Serial pool stats
    (SELECT COUNT(*) FROM serial_number_pool WHERE status = 'RESERVED') as reserved_serials,
    (SELECT COUNT(*) FROM serial_number_pool WHERE status = 'CONSUMED') as consumed_serials,
    
    -- Recent activity (last 24 hours)
    (SELECT COUNT(*) FROM trace_event WHERE event_timestamp > NOW() - INTERVAL '24 hours') as events_last_24h,
    (SELECT COUNT(*) FROM inventory WHERE created_at > NOW() - INTERVAL '24 hours') as items_created_24h;

-- =====================================================
-- 2. ALERTS/EXCEPTIONS VIEW
-- Items that need attention
-- =====================================================
CREATE OR REPLACE VIEW dashboard_alerts AS
SELECT * FROM (
    -- Items pending confirmation for more than 24 hours
    SELECT 
        'PENDING_CONFIRMATION' as alert_type,
        'Items pending scan confirmation > 24h' as description,
        id::TEXT as entity_id,
        'INVENTORY' as entity_type,
        serial_number as reference,
        created_at as alert_timestamp,
        'WARNING' as severity
    FROM inventory 
    WHERE status = 'PRE_INVENTORY' 
    AND created_at < NOW() - INTERVAL '24 hours'
    
    UNION ALL
    
    -- Partially filled containers older than 8 hours
    SELECT 
        'PARTIAL_CONTAINER' as alert_type,
        'Partially filled container > 8h' as description,
        id::TEXT as entity_id,
        'CONTAINER' as entity_type,
        serial_number as reference,
        created_at as alert_timestamp,
        'INFO' as severity
    FROM container_unit 
    WHERE status = 'PARTIAL' 
    AND created_at < NOW() - INTERVAL '8 hours'
    
    UNION ALL
    
    -- Voided serials
    SELECT 
        'VOIDED_SERIAL' as alert_type,
        'Voided serial number' as description,
        id::TEXT as entity_id,
        'SERIAL' as entity_type,
        serial_number as reference,
        reserved_at as alert_timestamp,
        'ERROR' as severity
    FROM serial_number_pool 
    WHERE status = 'VOIDED'
    AND reserved_at > NOW() - INTERVAL '7 days'
) alerts
ORDER BY 
    CASE severity 
        WHEN 'ERROR' THEN 1 
        WHEN 'WARNING' THEN 2 
        ELSE 3 
    END,
    alert_timestamp DESC
LIMIT 50;

-- =====================================================
-- 3. RECENT EVENTS VIEW
-- Last N events for the dashboard feed
-- =====================================================
CREATE OR REPLACE VIEW recent_events AS
SELECT 
    te.id,
    te.event_type,
    te.event_category,
    te.event_timestamp,
    te.location,
    te.notes,
    te.status,
    te."user",
    te.batch_number,
    i.serial_number as item_serial,
    m.name as material_name,
    cu.serial_number as container_serial
FROM trace_event te
LEFT JOIN inventory i ON te.inventory_id = i.id
LEFT JOIN materials m ON i.material_id = m.id
LEFT JOIN container_unit cu ON te.container_id = cu.id
ORDER BY te.event_timestamp DESC
LIMIT 100;

-- =====================================================
-- 4. FUNCTION: Get Item Full Timeline
-- Returns complete event history for an item
-- =====================================================
CREATE OR REPLACE FUNCTION get_item_timeline(
    p_serial_number TEXT
)
RETURNS TABLE (
    event_id BIGINT,
    event_type TEXT,
    event_category TEXT,
    event_ts TIMESTAMP WITH TIME ZONE,
    location TEXT,
    notes TEXT,
    user_name TEXT,
    container_serial TEXT,
    status TEXT
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_inventory_id BIGINT;
BEGIN
    -- Get inventory ID
    SELECT id INTO v_inventory_id FROM inventory WHERE serial_number = p_serial_number;
    
    IF v_inventory_id IS NULL THEN
        RETURN;
    END IF;
    
    RETURN QUERY
    SELECT 
        te.id,
        te.event_type,
        te.event_category,
        te.event_timestamp,
        te.location,
        te.notes,
        te."user",
        cu.serial_number,
        te.status
    FROM trace_event te
    LEFT JOIN container_unit cu ON te.container_id = cu.id
    WHERE te.inventory_id = v_inventory_id
    ORDER BY te.event_timestamp DESC;
END;
$$;

-- =====================================================
-- 5. FUNCTION: Get Container Timeline
-- Returns complete event history for a container
-- =====================================================
CREATE OR REPLACE FUNCTION get_container_timeline(
    p_container_serial TEXT
)
RETURNS TABLE (
    event_id BIGINT,
    event_type TEXT,
    event_category TEXT,
    event_ts TIMESTAMP WITH TIME ZONE,
    location TEXT,
    notes TEXT,
    user_name TEXT,
    item_count INTEGER,
    status TEXT
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_container_id BIGINT;
BEGIN
    -- Get container ID
    SELECT id INTO v_container_id FROM container_unit WHERE serial_number = p_container_serial;
    
    IF v_container_id IS NULL THEN
        RETURN;
    END IF;
    
    RETURN QUERY
    SELECT 
        te.id,
        te.event_type,
        te.event_category,
        te.event_timestamp,
        te.location,
        te.notes,
        te."user",
        jsonb_array_length(COALESCE(te.child_ids, '[]'::jsonb))::INTEGER,
        te.status
    FROM trace_event te
    WHERE te.container_id = v_container_id 
       OR te.parent_container_id = v_container_id
    ORDER BY te.event_timestamp DESC;
END;
$$;

-- =====================================================
-- 6. FUNCTION: Get Item Hierarchy
-- Returns the full parent chain for an item
-- =====================================================
CREATE OR REPLACE FUNCTION get_item_hierarchy(
    p_serial_number TEXT
)
RETURNS TABLE (
    level_num INTEGER,
    entity_type TEXT,
    entity_id BIGINT,
    serial_number TEXT,
    entity_name TEXT,
    status TEXT
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_current_type TEXT;
    v_current_id BIGINT;
    v_level INTEGER := 0;
    v_agg RECORD;
    v_item_status TEXT;
BEGIN
    -- Start with the inventory item
    SELECT i.id, i.status INTO v_current_id, v_item_status
    FROM inventory i WHERE i.serial_number = p_serial_number;
    
    IF v_current_id IS NULL THEN
        RETURN;
    END IF;
    
    -- Return the item itself
    RETURN QUERY SELECT 
        v_level,
        'INVENTORY'::TEXT,
        v_current_id,
        p_serial_number,
        (SELECT m.name FROM materials m JOIN inventory inv ON m.id = inv.material_id WHERE inv.id = v_current_id),
        v_item_status;
    
    v_current_type := 'INVENTORY';
    
    -- Traverse up the hierarchy
    LOOP
        SELECT a.parent_type, a.parent_id, cu.serial_number, cu.container_type, cu.status
        INTO v_agg
        FROM aggregation a
        JOIN container_unit cu ON a.parent_id = cu.id
        WHERE a.child_type = v_current_type
        AND a.child_id = v_current_id
        AND a.status = 'ACTIVE';
        
        EXIT WHEN NOT FOUND;
        
        v_level := v_level + 1;
        
        RETURN QUERY SELECT 
            v_level,
            v_agg.parent_type,
            v_agg.parent_id,
            v_agg.serial_number,
            v_agg.container_type,
            v_agg.status;
        
        v_current_type := v_agg.parent_type;
        v_current_id := v_agg.parent_id;
    END LOOP;
END;
$$;

-- =====================================================
-- 7. INVENTORY BY STAGE FOR DASHBOARD
-- Returns counts grouped by status
-- =====================================================
CREATE OR REPLACE FUNCTION get_inventory_by_stage()
RETURNS TABLE (
    stage TEXT,
    count BIGINT,
    percentage NUMERIC
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_total BIGINT;
BEGIN
    SELECT COUNT(*) INTO v_total FROM inventory;
    
    IF v_total = 0 THEN
        v_total := 1; -- Avoid division by zero
    END IF;
    
    RETURN QUERY
    SELECT 
        inv.status,
        COUNT(*),
        ROUND((COUNT(*)::NUMERIC / v_total) * 100, 1)
    FROM inventory inv
    GROUP BY inv.status
    ORDER BY 
        CASE inv.status
            WHEN 'PRE_INVENTORY' THEN 1
            WHEN 'ACTIVE' THEN 2
            WHEN 'PACKED' THEN 3
            WHEN 'SHIPPED' THEN 4
            WHEN 'DELIVERED' THEN 5
            ELSE 6
        END;
END;
$$;

-- =====================================================
-- MIGRATION COMPLETE
-- =====================================================
