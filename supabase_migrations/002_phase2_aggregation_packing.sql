-- =====================================================
-- TraceRoo Phase 2: Aggregation & Packing
-- Supabase Migration Script
-- Run this in Supabase SQL Editor AFTER Phase 1
-- =====================================================

-- =====================================================
-- 1. AGGREGATION TABLE
-- Tracks parent-child relationships between items and containers
-- =====================================================
CREATE TABLE IF NOT EXISTS aggregation (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    parent_type TEXT NOT NULL CHECK (parent_type IN ('BOX', 'PALLET', 'SHIPPING_CONTAINER')),
    parent_id BIGINT NOT NULL,
    child_type TEXT NOT NULL CHECK (child_type IN ('INVENTORY', 'BOX', 'PALLET')),
    child_id BIGINT NOT NULL,
    aggregated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    disaggregated_at TIMESTAMP WITH TIME ZONE,
    status TEXT DEFAULT 'ACTIVE' CHECK (status IN ('ACTIVE', 'DISAGGREGATED')),
    aggregation_event_id BIGINT,
    disaggregation_event_id BIGINT,
    created_by TEXT,
    UNIQUE(child_type, child_id, status) -- Each child can only be in one active parent
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_aggregation_parent ON aggregation(parent_type, parent_id);
CREATE INDEX IF NOT EXISTS idx_aggregation_child ON aggregation(child_type, child_id);
CREATE INDEX IF NOT EXISTS idx_aggregation_status ON aggregation(status);

-- =====================================================
-- 2. ENHANCE CONTAINER_UNIT TABLE
-- Add missing columns for tracking
-- =====================================================
-- First, create container_unit if it doesn't exist
CREATE TABLE IF NOT EXISTS container_unit (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    serial_number TEXT UNIQUE NOT NULL,
    container_type TEXT NOT NULL CHECK (container_type IN ('BOX', 'PALLET', 'SHIPPING_CONTAINER')),
    status TEXT DEFAULT 'EMPTY' CHECK (status IN ('EMPTY', 'PARTIAL', 'FULL', 'SEALED', 'SHIPPED', 'DELIVERED')),
    location_id UUID REFERENCES locations(id),
    parent_container_id BIGINT REFERENCES container_unit(id),
    packaging_level_id UUID REFERENCES packaging_level(id),
    capacity INTEGER, -- Max items this container can hold
    current_count INTEGER DEFAULT 0, -- Current items in container
    batch_number TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    sealed_at TIMESTAMP WITH TIME ZONE,
    created_by TEXT
);

CREATE INDEX IF NOT EXISTS idx_container_serial ON container_unit(serial_number);
CREATE INDEX IF NOT EXISTS idx_container_type ON container_unit(container_type);
CREATE INDEX IF NOT EXISTS idx_container_status ON container_unit(status);
CREATE INDEX IF NOT EXISTS idx_container_location ON container_unit(location_id);

-- =====================================================
-- 3. ENHANCED TRACE_EVENT TABLE
-- Add columns for aggregation events
-- =====================================================
ALTER TABLE trace_event ADD COLUMN IF NOT EXISTS event_category TEXT 
    CHECK (event_category IN ('OBJECT', 'AGGREGATION', 'DISAGGREGATION', 'TRANSFER', 'SHIPMENT', 'EXCEPTION'));
ALTER TABLE trace_event ADD COLUMN IF NOT EXISTS batch_number TEXT;
ALTER TABLE trace_event ADD COLUMN IF NOT EXISTS order_reference TEXT;
ALTER TABLE trace_event ADD COLUMN IF NOT EXISTS owner TEXT;
ALTER TABLE trace_event ADD COLUMN IF NOT EXISTS shipment_id BIGINT;
ALTER TABLE trace_event ADD COLUMN IF NOT EXISTS parent_container_id BIGINT;
ALTER TABLE trace_event ADD COLUMN IF NOT EXISTS child_ids JSONB; -- Array of child IDs
ALTER TABLE trace_event ADD COLUMN IF NOT EXISTS location_id UUID REFERENCES locations(id);

-- =====================================================
-- 4. ROW LEVEL SECURITY FOR NEW TABLES
-- =====================================================
ALTER TABLE aggregation ENABLE ROW LEVEL SECURITY;
ALTER TABLE container_unit ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Enable all access for authenticated users" ON aggregation
    FOR ALL TO authenticated USING (true) WITH CHECK (true);

CREATE POLICY "Enable read access for anon" ON aggregation
    FOR SELECT TO anon USING (true);

CREATE POLICY "Enable all access for authenticated users" ON container_unit
    FOR ALL TO authenticated USING (true) WITH CHECK (true);

CREATE POLICY "Enable read access for anon" ON container_unit
    FOR SELECT TO anon USING (true);

-- =====================================================
-- 5. FUNCTION: Generate Container Serial Number
-- Format: {TYPE}-DDMMYYYY-{XXXXX}
-- =====================================================
CREATE OR REPLACE FUNCTION generate_container_serial(
    p_container_type TEXT
)
RETURNS TEXT
LANGUAGE plpgsql
AS $$
DECLARE
    v_prefix TEXT;
    v_date_part TEXT;
    v_sequence INT;
    v_serial TEXT;
BEGIN
    -- Set prefix based on type
    v_prefix := CASE p_container_type
        WHEN 'BOX' THEN 'BOX'
        WHEN 'PALLET' THEN 'PLT'
        WHEN 'SHIPPING_CONTAINER' THEN 'CNT'
        ELSE 'PKG'
    END;
    
    -- Get current date in DDMMYYYY format
    v_date_part := TO_CHAR(CURRENT_DATE, 'DDMMYYYY');
    
    -- Get the next sequence number for this type and date
    SELECT COALESCE(MAX(
        CAST(SUBSTRING(serial_number FROM '[0-9]+$') AS INTEGER)
    ), 0) + 1
    INTO v_sequence
    FROM container_unit
    WHERE container_type = p_container_type
    AND serial_number LIKE v_prefix || '-' || v_date_part || '-%';
    
    -- Format serial number
    v_serial := v_prefix || '-' || v_date_part || '-' || LPAD(v_sequence::TEXT, 5, '0');
    
    RETURN v_serial;
END;
$$;

-- =====================================================
-- 6. FUNCTION: Create Container
-- Creates a new container with auto-generated serial
-- =====================================================
CREATE OR REPLACE FUNCTION create_container(
    p_container_type TEXT,
    p_packaging_level_id UUID DEFAULT NULL,
    p_location_id UUID DEFAULT NULL,
    p_capacity INTEGER DEFAULT NULL,
    p_batch_number TEXT DEFAULT NULL,
    p_created_by TEXT DEFAULT NULL
)
RETURNS container_unit
LANGUAGE plpgsql
AS $$
DECLARE
    v_serial TEXT;
    v_container container_unit;
BEGIN
    -- Generate serial number
    v_serial := generate_container_serial(p_container_type);
    
    -- Insert container
    INSERT INTO container_unit (
        serial_number, container_type, packaging_level_id, 
        location_id, capacity, batch_number, created_by
    )
    VALUES (
        v_serial, p_container_type, p_packaging_level_id,
        p_location_id, p_capacity, p_batch_number, p_created_by
    )
    RETURNING * INTO v_container;
    
    RETURN v_container;
END;
$$;

-- =====================================================
-- 7. FUNCTION: Pack Items into Container
-- Adds items/containers to a parent container
-- =====================================================
CREATE OR REPLACE FUNCTION pack_items(
    p_parent_id BIGINT,
    p_child_type TEXT,
    p_child_ids BIGINT[],
    p_created_by TEXT DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
AS $$
DECLARE
    v_parent container_unit;
    v_child_id BIGINT;
    v_event_id BIGINT;
    v_packed_count INT := 0;
    v_errors JSONB := '[]'::JSONB;
BEGIN
    -- Get parent container
    SELECT * INTO v_parent FROM container_unit WHERE id = p_parent_id;
    
    IF v_parent IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Parent container not found');
    END IF;
    
    -- Check capacity
    IF v_parent.capacity IS NOT NULL AND 
       (v_parent.current_count + array_length(p_child_ids, 1)) > v_parent.capacity THEN
        RETURN jsonb_build_object('success', false, 'error', 'Container capacity exceeded');
    END IF;
    
    -- Create aggregation event
    INSERT INTO trace_event (
        event_type, event_category, event_timestamp, location, 
        notes, status, child_ids, parent_container_id
    )
    VALUES (
        'PACK', 'AGGREGATION', NOW(), 
        (SELECT name FROM locations WHERE id = v_parent.location_id),
        'Items packed into container ' || v_parent.serial_number,
        'SUCCESS',
        to_jsonb(p_child_ids),
        p_parent_id
    )
    RETURNING id INTO v_event_id;
    
    -- Pack each item
    FOREACH v_child_id IN ARRAY p_child_ids LOOP
        BEGIN
            -- Insert aggregation record
            INSERT INTO aggregation (
                parent_type, parent_id, child_type, child_id,
                aggregation_event_id, created_by
            )
            VALUES (
                v_parent.container_type, p_parent_id, p_child_type, v_child_id,
                v_event_id, p_created_by
            );
            
            -- Update child's parent reference if it's inventory
            IF p_child_type = 'INVENTORY' THEN
                UPDATE inventory 
                SET parent_container_type = v_parent.container_type,
                    parent_container_id = p_parent_id,
                    status = 'PACKED'
                WHERE id = v_child_id;
            ELSIF p_child_type IN ('BOX', 'PALLET') THEN
                UPDATE container_unit 
                SET parent_container_id = p_parent_id
                WHERE id = v_child_id;
            END IF;
            
            v_packed_count := v_packed_count + 1;
        EXCEPTION WHEN unique_violation THEN
            v_errors := v_errors || jsonb_build_object('child_id', v_child_id, 'error', 'Already packed');
        END;
    END LOOP;
    
    -- Update parent container count and status
    UPDATE container_unit 
    SET current_count = current_count + v_packed_count,
        status = CASE 
            WHEN current_count + v_packed_count >= COALESCE(capacity, 999999) THEN 'FULL'
            WHEN current_count + v_packed_count > 0 THEN 'PARTIAL'
            ELSE status
        END
    WHERE id = p_parent_id;
    
    RETURN jsonb_build_object(
        'success', true, 
        'packed_count', v_packed_count,
        'errors', v_errors,
        'event_id', v_event_id
    );
END;
$$;

-- =====================================================
-- 8. FUNCTION: Unpack Items from Container
-- Removes items/containers from a parent container
-- =====================================================
CREATE OR REPLACE FUNCTION unpack_items(
    p_parent_id BIGINT,
    p_child_type TEXT,
    p_child_ids BIGINT[],
    p_created_by TEXT DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
AS $$
DECLARE
    v_parent container_unit;
    v_child_id BIGINT;
    v_event_id BIGINT;
    v_unpacked_count INT := 0;
BEGIN
    -- Get parent container
    SELECT * INTO v_parent FROM container_unit WHERE id = p_parent_id;
    
    IF v_parent IS NULL THEN
        RETURN jsonb_build_object('success', false, 'error', 'Parent container not found');
    END IF;
    
    -- Create disaggregation event
    INSERT INTO trace_event (
        event_type, event_category, event_timestamp, location,
        notes, status, child_ids, parent_container_id
    )
    VALUES (
        'UNPACK', 'DISAGGREGATION', NOW(),
        (SELECT name FROM locations WHERE id = v_parent.location_id),
        'Items unpacked from container ' || v_parent.serial_number,
        'SUCCESS',
        to_jsonb(p_child_ids),
        p_parent_id
    )
    RETURNING id INTO v_event_id;
    
    -- Unpack each item
    FOREACH v_child_id IN ARRAY p_child_ids LOOP
        -- Update aggregation record
        UPDATE aggregation
        SET status = 'DISAGGREGATED',
            disaggregated_at = NOW(),
            disaggregation_event_id = v_event_id
        WHERE parent_id = p_parent_id 
        AND child_type = p_child_type 
        AND child_id = v_child_id
        AND status = 'ACTIVE';
        
        IF FOUND THEN
            -- Update child's parent reference
            IF p_child_type = 'INVENTORY' THEN
                UPDATE inventory 
                SET parent_container_type = NULL,
                    parent_container_id = NULL,
                    status = 'ACTIVE'
                WHERE id = v_child_id;
            ELSIF p_child_type IN ('BOX', 'PALLET') THEN
                UPDATE container_unit 
                SET parent_container_id = NULL
                WHERE id = v_child_id;
            END IF;
            
            v_unpacked_count := v_unpacked_count + 1;
        END IF;
    END LOOP;
    
    -- Update parent container count and status
    UPDATE container_unit 
    SET current_count = GREATEST(0, current_count - v_unpacked_count),
        status = CASE 
            WHEN current_count - v_unpacked_count <= 0 THEN 'EMPTY'
            ELSE 'PARTIAL'
        END
    WHERE id = p_parent_id;
    
    RETURN jsonb_build_object(
        'success', true, 
        'unpacked_count', v_unpacked_count,
        'event_id', v_event_id
    );
END;
$$;

-- =====================================================
-- 9. FUNCTION: Get Container Contents
-- Returns all items/containers inside a container
-- =====================================================
CREATE OR REPLACE FUNCTION get_container_contents(
    p_container_id BIGINT
)
RETURNS TABLE (
    aggregation_id BIGINT,
    child_type TEXT,
    child_id BIGINT,
    child_serial TEXT,
    child_name TEXT,
    aggregated_at TIMESTAMP WITH TIME ZONE
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT 
        a.id AS aggregation_id,
        a.child_type,
        a.child_id,
        CASE 
            WHEN a.child_type = 'INVENTORY' THEN i.serial_number
            ELSE cu.serial_number
        END AS child_serial,
        CASE 
            WHEN a.child_type = 'INVENTORY' THEN m.name
            ELSE cu.container_type
        END AS child_name,
        a.aggregated_at
    FROM aggregation a
    LEFT JOIN inventory i ON a.child_type = 'INVENTORY' AND a.child_id = i.id
    LEFT JOIN materials m ON i.material_id = m.id
    LEFT JOIN container_unit cu ON a.child_type IN ('BOX', 'PALLET') AND a.child_id = cu.id
    WHERE a.parent_id = p_container_id
    AND a.status = 'ACTIVE'
    ORDER BY a.aggregated_at DESC;
END;
$$;

-- =====================================================
-- 10. VIEW: Container Summary
-- Quick view of all containers with content counts
-- =====================================================
CREATE OR REPLACE VIEW container_summary AS
SELECT 
    cu.id,
    cu.serial_number,
    cu.container_type,
    cu.status,
    cu.capacity,
    cu.current_count,
    CASE 
        WHEN cu.capacity IS NULL THEN 'N/A'
        ELSE ROUND((cu.current_count::NUMERIC / cu.capacity) * 100) || '%'
    END as fill_percentage,
    l.name as location_name,
    pl.level_name as packaging_level,
    cu.created_at
FROM container_unit cu
LEFT JOIN locations l ON cu.location_id = l.id
LEFT JOIN packaging_level pl ON cu.packaging_level_id = pl.id
ORDER BY cu.created_at DESC;

-- =====================================================
-- MIGRATION COMPLETE
-- =====================================================
